# 目次
- 概要
    - 一言で言うと
    - 学習の際の注意点
- 用語
- 実装準備
    - 開発ツール
    - デバッグ
    - Lightningコンポーネント開発準備
- 実装

# Lightningコンポーネント
## 概要
### 一言で言うと
動的なWebアプリケーションを開発するためのUIフレームワーク。
サーバー側ではApex、クライアント側ではJavascriptで動く。
カプセル化されたコンポーネントを組み合わせる（コンポジション）ことで迅速な開発を可能にする。

### 学習の際の注意点
Lightning コンポーネントフレームワークは Visualforce よりも大規模であり、洗練され、複雑です。
それほど機能的でない Lightning コンポーネントアプリケーションを記述する場合でさえ、JavaScript に精通している必要があります。
他言語と比較してjavascriptは学習する必要がある十分な違いが存在します。たとえば、オブジェクトと継承、範囲ルール、真と偽を分ける予測不能な動作などです。
Visualforce コードを Lightning コンポーネント形式で記述しない。Lightning コンポーネントの優れたコードの設計とアーキテクチャは、Visualforce の優れたコードとは別物です。
- javascriptは大文字と小文字が区別される（Apex、Visualforceと異なる）
- javascriptは静的リソース以外の場所のものを読み込めない
- IE11はCSPをサポートしないため、LockerServiceが無効化される。セキュリティに問題が出てくる。



## 用語
### コンポーネント（バンドル）
LightningコンポーネントによるWebアプリケーションの構成単位。
インスタンスとして利用できるため、再利用性高い。
HTML、CSS、javascript

### コンポーネント

### イベント
インターフェースイベント発生時に対応するハンドラを作成する。

### Lightning 基本コンポーネント

### Field Service Lightning 
### Lightning Design System
cssフレームワーク。Salesforceの提供サービスが利用しているデザインを利用できる。商用可。
積極的に使う。独自のCSSスタイルは最終手段的に限定された特別なケースでのみ使用。
#### 注意点
SLDS コンポーネントは Lightning コンポーネントではありません。Lightning 組み込みコンポーネントの中で必要なものが見つからない場合、自分でコンポーネントを作成するための開始点として SLDS サイトを使用します。（SLDS は、Salesforce が目指している未来の世界を表します。）


## 実装準備
### Lightningコンポーネント開発準備
1. カスタムSalesforceドメイン名を定義していること。
2. Lightningコンポーネントプレビュー用のハーネスアプリケーション（Lightningコンポーネントをラップする開発用のLightningアプリケーション）
    アクセス: '/c/harnessApp.app'

## 実装
### 設計手順
アプリケーションをコンポーネントに分解する。
最初に最も小さく、最も内側のコンポーネントから作成していく。

### コントローラ（Apex）
状態を格納できない。
ナビゲーションロジックは実装できない（PageReferenceを返せない）。
- public クラス
- @AuraEnabled public static メソッド
- 仮引数名はクライアント側でアクションを作成するときに使用するパラメータ名と一致させることが強く推奨される。
- サーバ側のメソッド名とクライアント側のアクションハンドラの関数名は同じにしないことが強く推奨される。

### コントローラ（javascript）
名前:値ペアの対応付けが含まれる JSON オブジェクトです。アクションハンドラ（匿名関数）のみを含めることができます。
引数は、component、event、helperをとる。
#### コンポーネントのプロパティにアクセスする方法
componentのgetメソッドとsetメソッドを使用する

```
component.get("v.プロパティ名");
component.set("v.プロパティ名", 値);
```

### ヘルパー
再利用する関数を配置する。
任意の引数を取れるが、慣例として最初の引数はヘルパーを呼び出すコンポーネントの参照。
ヘルパーはシングルトンで、すべてのコンポーネントインスタンスで共有される（cf.静的メソッド）。
ヘルパーには関数以外を追加できます。また、一度だけ読み込まれる API ログイン情報などの値をコントローラアクションハンドラに提供することもできます。ただし、これは共有変数で、不正なアクセスを防ぐものがない、ということを覚えておく必要があります。この方法は、よく考えてから使用してください。

### コントローラとヘルパー
アクションハンドラはできるだけシンプルで分かりやすくするのがベストプラクティスだと考え、詳細情報をヘルパーに抽出する人が多くいます。これはこれで良識的な方法ですが、他にも方法はあります。
複数のアクションハンドラで再利用するコードはヘルパーに入れることをお勧めします。それ以外は、各自の好みとスタイル、組織のコーディング基準に従って決めてください。

### 式と値プロパイダ
#### v.プロパティ名
v.は表示の値プロバイダで、そのものがコンポーネントです。コンポーネントの属性を参照するには、この方法を使用します。
値プロパイダは省略できない。
#### （コンポーネント内）c.アクション名
c.はコントローラ（javascript）の値プロパイダ。関数を呼び出すのに使う。
#### （コントローラ内）c.
c.はコントローラ（Apex）の値プロパイダ。
#### バインド式
その値が使用されているすべての場所の間で双方向バインドを作成し、Lightning コンポーネントに魔法のように作用します。ある箇所で値を変更すると、その値がすべての場所で変更されます。

```
{! v.messageText }
```

#### 非バインド式

```
{# v.messageText }
```

## Lightning Design System
### 使用方法1
1. https://www.lightningdesignsystem.com/ から使用したいコンポネントを見つける
2. 使用箇所にコメントでLDSを使用する旨を記載する（保守開発を用意にするため）

``` 
<!--
    Lightning Design System の data table を使用する
    https://www.lightningdesignsystem.com/components/data-tables/
-->
```

3. コードをコピペする
4. 目的に合わせてクラスを変更する
5. 目的に合わせてコードを修正する

## デバッグ
コードのどの行で失敗しているのかをすばやく見つけるには、コードを実行する前に [Pause on all exceptions (すべての例外で一時停止)] オプションを有効にします。
ツール
- [Chrome DevTools](https://developers.google.com/web/tools/chrome-devtools/)
- [Salesforce Lightning Inspector](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/inspector_intro.htm)
### ログ出力
変数に何が含まれているかが分かるような詳細情報が入ったログがあるだけで解決の糸口になることもあります。

```
console.log('someVariable: ' + JSON.stringify(someVariable));
```

### Salesforce Lightning Inspector 
[Salesforce Lightning Inspector](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/inspector_use.htm)
コンポーネント間のやりとりを診断するとき => [Event Log (イベントログ)] タブ
サーバ要求の問題を診断するとき => [Actions (アクション)] タブ
[イベント処理のライフサイクル](https://developer.salesforce.com/docs/atlas.ja-jp.210.0.lightning.meta/lightning/events_overview.htm)について、もっと学ぶ必要もあるかもしれません。
### デバッグモード
デバッグモードが有効になっていることを確認してください。デバッグモードを有効にすると、ダウンロードされた JavaScript が縮小されるのを回避できます。または、高度なデバッグ作業に必要な詳細情報を簡単に取得できるようになります。デバッグ作業でコードのトレースが必要な場合は、必ずデバッグモードを有効にしてください。有効にしないと、コードを判読できません。

# 実装のヒント
## 継承とコンポジション
Lightningコンポネントは親コンポネントを継承できる。
しかし、継承よりもコンポジションを優先させる。
- フレームワークの実装で継承を使用するとパフォーマンスに大きく影響する。
- Lightningコンポーネントの継承の動作は気まぐれ。親関数の書換えはできるが拡張はできない。
- フレームワークの仕様が変わるおそれがあるため、複雑な継承階層は使用すべきでない。

## ApexとLightningコンポネント
### Apex は JavaScript ではない
Apex から JavaScript にデータを返すときに 変換 - 逐次化 - 送信 - 並列化 というプロセスを経る。
データをパッケージ化して Lightning コンポーネントに返すための専用の Apex クラスを作成すると若干複雑さが減り、デバッグも容易になる。
### sObject
JavaScript コードで、カスタムオブジェクトを含む新しい sObject を作成することができます。少しだけ長くなりますが、分かりやすい構文です。これらの sObject は、要求時にパラメータとしてサーバ側 Apex に送信できます。Apex からの応答に sObject を返すことができ、変換はフレームワークによって行われます。
### カスタムクラス
#### javascript => Apex
通常、カスタムの Apex クラスをクライアント側 JavaScript からサーバ側 Apex にパラメータとして渡すことはできません。この場合はプレーンな JavaScript オブジェクトを使用して、パラメータの構造化データをカプセル化します。必要に応じて、たとえば Apex クラスのコンストラクタなどの Apex コードで、そのオブジェクトを解析します。
#### Apex => javascript
カスタム Apex クラスは、サーバ側コントローラから応答としてクライアント側 JavaScript に返すことができます。ただし、カスタム Apex クラスはそのプロセスの一部として逐次化・並列化されるため、予想とは異なる結果になることがあります。 含めたいデータ要素や自分で作成した JSON と一緒にマップを返す方が良いことが多いです。
### 内部クラス
 Apex 内部クラスは Lightning コンポーネントコードでは使用できません。サーバ側 Apex コードでは、要求の処理時に内部クラスを使用することができますが、クライアントに返される応答を内部クラスのインスタンスにすることはできません。
### 継承
 Lightning コンポーネントへの応答で返す予定のカスタム Apex クラスに継承を使用することはできません。
### サーバ側エラーの処理
 Apex コードでエラーが発生した場合、AuraHandledException を作成して発生させることができます。DML 例外などの他の例外をキャッチして、AuraHandledException として再発生させても、クライアント側での操作性が大幅に向上します。

 ```
 throw new AuraHandledException('HOGE HOGE.')
 ```




# 未整理

スタイル
ドキュメント
レンダラ
設計
SVG

最後に、Visualforce のアプリ内コンポーネントリファレンスと同じように、組織にインストールしたコンポーネントの動的リファレンスとして、https://<yourDomain>.lightning.force.com/auradocs/reference.app にあるリファレンスドキュメントアプリケーションを見てみてください。


```
<aura:component controller="AccountsController">
    <aura:attribute name="accounts" action="{!c.doInit}"/>
    <aura:handler name="init" value="{!this}" action="{!c.doInit}"/>
</aura:component>	

```


### aura名前空間
アプリケーションロジックを簡略化するコンポーネント
### ui名前空間
ボタン、入力項目などユーザインターフェース
### force名前空間
Salesforce固有のコンポーネント




たとえば、one.app コンテナ (Lightning Experience と Salesforce アプリケーション) では、レコードに移動する、レコードを作成または編集する、URL を開くといった、イベントの処理がサービスとして提供されます。
他のコンテナではこれらのサービスは提供されません。あるコンテナのサービスに依存するコンポーネントは、そのサービスが提供されない別のコンテナでは機能しません。たとえば、新規レコードの作成に force:createRecord イベントを使用すると、Lightning Experience では適切に機能しますが、そのコンポーネントをスタンドアロンアプリケーションや Lightning Out 内で使用すると、イベントを処理するものがないため、動作が停止します
ここが重要な部分です。Lightning コンポーネントコードは、それを内部で実行するコンテナのサービスのみにアクセスできます。そのコンテナが別のコンテナの内部にある場合も同じです。




ヘルパーはシングルトンであり、コンポーネントのすべてのインスタンスで共有されます。


コントローラ JavaScript コードで属性値を取得および設定するには get メソッドと setメソッドを使用します。
 


コンポーネントの属性の値を他のコンポーネントが操作できないようにするには、属性を private にします。そうしない場合は、属性がコンポーネントの公開 API の一部になります。
非公開属性の名前には、プレフィックスとしてアンダースコアを使用して (_myAttribute など)、非公開属性であることを明確にするとよいでしょう)


expando は軽微なバグやメモリーリークにつながる場合があるということです。うまく機能すると思われる一方で、問題が発生する可能性も捨てきれません。そのため、Salesorce では expando の使用はお勧めしません。










Lightning コンポーネントフレームワークは、Visualforce のこれらの制限事項に対処するように設計されました。特に、コンポーネントは (意図的に) 疎結合されています。この疎結合のメカニズムがイベントです。








Lightning コンポーネントコントローラのコードはクライアント側で実行されますが、データはサーバ側に保存されます。キャッシュがない場合、新しいデータが必要になるたびに何らかのサーバ要求を行うことになります。それはおそらく、Visualforce コントローラであれば記述することがなかったコードです。


